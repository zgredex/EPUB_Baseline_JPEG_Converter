<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Baseline JPEG Converter</title>
    <link href="https://fonts.googleapis.com/css2?family=Atkinson+Hyperlegible+Next:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg-primary: #0d0a12;
            --bg-secondary: #15111d;
            --bg-tertiary: #1e1829;
            --accent: #a78bfa;
            --accent-dim: #8b5cf6;
            --accent-bright: #c4b5fd;
            --accent-glow: rgba(167, 139, 250, 0.15);
            --text-primary: #f5f3ff;
            --text-secondary: #a8a3b8;
            --text-tertiary: #6b6580;
            --border: #2e2640;
            --error: #f87171;
            --warning: #fbbf24;
            --info: #818cf8;
            --font: 'Atkinson Hyperlegible Next', sans-serif;
        }
        body { font-family: var(--font); background: var(--bg-primary); color: var(--text-primary); min-height: 100vh; }
        .grain { position: fixed; inset: 0; pointer-events: none; opacity: 0.03; z-index: 1000; background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E"); }
        .container { max-width: 720px; margin: 0 auto; padding: 60px 24px; position: relative; z-index: 1; }
        header { text-align: center; margin-bottom: 48px; }
        .logo { display: inline-flex; align-items: center; gap: 12px; margin-bottom: 16px; }
        .logo-icon { width: 48px; height: 48px; background: linear-gradient(135deg, var(--accent), var(--accent-dim)); border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: 24px; box-shadow: 0 8px 32px var(--accent-glow); }
        h1 { font-size: 2rem; font-weight: 700; letter-spacing: -0.02em; }
        .subtitle { color: var(--text-secondary); font-size: 1.05rem; margin-top: 8px; }
        .drop-zone { border: 2px dashed var(--border); border-radius: 16px; padding: 64px 32px; text-align: center; cursor: pointer; transition: all 0.2s; background: var(--bg-secondary); position: relative; overflow: hidden; }
        .drop-zone::before { content: ''; position: absolute; inset: 0; background: radial-gradient(circle at center, var(--accent-glow), transparent 70%); opacity: 0; transition: opacity 0.3s; }
        .drop-zone:hover, .drop-zone.drag-over { border-color: var(--accent); background: var(--bg-tertiary); }
        .drop-zone:hover::before, .drop-zone.drag-over::before { opacity: 1; }
        .drop-zone-icon { font-size: 48px; margin-bottom: 16px; display: block; }
        .drop-zone-text { font-size: 1.1rem; color: var(--text-secondary); margin-bottom: 8px; }
        .drop-zone-hint { font-size: 0.85rem; color: var(--text-tertiary); }
        #file-input { display: none; }
        .file-info { background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 12px; padding: 20px; margin-top: 24px; display: none; }
        .file-info.visible { display: block; animation: slideUp 0.3s; }
        @keyframes slideUp { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .file-header { display: flex; align-items: center; gap: 12px; margin-bottom: 16px; }
        .file-icon { width: 40px; height: 40px; background: var(--bg-tertiary); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 20px; }
        .file-name { font-weight: 500; flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .file-size { color: var(--text-tertiary); font-size: 0.85rem; }
        .stats-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; margin-top: 16px; }
        .stat-box { background: var(--bg-tertiary); border-radius: 8px; padding: 12px; text-align: center; }
        .stat-value { font-size: 1.5rem; font-weight: 600; color: var(--accent); }
        .stat-label { font-size: 0.75rem; color: var(--text-tertiary); text-transform: uppercase; letter-spacing: 0.05em; margin-top: 4px; }
        .validation-section { background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 12px; padding: 16px 20px; margin-top: 16px; display: none; }
        .validation-section.visible { display: block; animation: slideUp 0.3s; }
        .validation-header { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; }
        .validation-icon { font-size: 1.2rem; }
        .validation-title { font-weight: 500; font-size: 0.95rem; }
        .validation-section.success { border-color: #22c55e33; }
        .validation-section.success .validation-title { color: #4ade80; }
        .validation-section.warning { border-color: #f59e0b33; }
        .validation-section.warning .validation-title { color: #fbbf24; }
        .validation-section.error { border-color: #ef444433; }
        .validation-section.error .validation-title { color: #f87171; }
        .validation-issues { font-size: 0.85rem; color: var(--text-secondary); }
        .validation-issue { display: flex; align-items: flex-start; gap: 8px; padding: 6px 0; }
        .validation-issue.error { color: #f87171; }
        .validation-issue.warning { color: #fbbf24; }
        .validation-issue.success { color: #4ade80; }
        .validation-issue.info { color: var(--info); }
        .quality-section { background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 12px; padding: 20px; margin-top: 24px; display: none; }
        .quality-section.visible { display: block; animation: slideUp 0.3s; }
        .quality-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
        .quality-label { font-size: 0.95rem; color: var(--text-secondary); display: flex; align-items: center; gap: 8px; }
        .quality-input-wrapper { display: flex; align-items: center; gap: 6px; background: var(--bg-tertiary); padding: 6px 12px; border-radius: 8px; border: 1px solid var(--border); }
        .quality-input { width: 48px; padding: 4px; border: none; background: transparent; color: var(--text-primary); font-family: var(--font); font-size: 1rem; font-weight: 600; text-align: right; }
        .quality-input:focus { outline: none; }
        .quality-input::-webkit-inner-spin-button, .quality-input::-webkit-outer-spin-button { -webkit-appearance: none; }
        .quality-input[type=number] { -moz-appearance: textfield; }
        .quality-percent { color: var(--text-tertiary); font-size: 0.9rem; }
        .quality-slider { width: 100%; height: 6px; border-radius: 3px; background: var(--bg-tertiary); -webkit-appearance: none; cursor: pointer; margin: 8px 0; }
        .quality-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; border-radius: 50%; background: linear-gradient(135deg, var(--accent-bright), var(--accent-dim)); cursor: pointer; box-shadow: 0 2px 8px var(--accent-glow); }
        .quality-slider::-webkit-slider-thumb:hover { transform: scale(1.15); }
        .quality-slider::-moz-range-thumb { width: 20px; height: 20px; border-radius: 50%; background: linear-gradient(135deg, var(--accent-bright), var(--accent-dim)); border: none; }
        .quality-hints { display: flex; justify-content: space-between; font-size: 0.75rem; color: var(--text-tertiary); }
        .quality-presets { display: flex; gap: 8px; margin-top: 16px; }
        .quality-preset { flex: 1; padding: 8px 12px; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 6px; color: var(--text-secondary); font-family: var(--font); font-size: 0.8rem; cursor: pointer; transition: all 0.15s; text-align: center; }
        .quality-preset:hover { border-color: var(--accent); color: var(--text-primary); }
        .quality-preset.active { border-color: var(--accent); background: var(--accent-glow); color: var(--accent); }
        .progress-section { margin-top: 24px; display: none; }
        .progress-section.visible { display: block; }
        .progress-bar-container { background: var(--bg-tertiary); border-radius: 8px; height: 8px; overflow: hidden; }
        .progress-bar { height: 100%; background: linear-gradient(90deg, var(--accent), var(--accent-dim)); border-radius: 8px; width: 0%; transition: width 0.3s; }
        .progress-text { display: flex; justify-content: space-between; margin-top: 8px; font-size: 0.85rem; color: var(--text-secondary); }
        .btn { display: inline-flex; align-items: center; justify-content: center; gap: 8px; padding: 14px 28px; border-radius: 10px; font-family: var(--font); font-size: 1rem; font-weight: 500; cursor: pointer; transition: all 0.2s; border: none; width: 100%; margin-top: 24px; }
        .btn-primary { background: linear-gradient(135deg, var(--accent), var(--accent-dim)); color: #0d0a12; box-shadow: 0 4px 24px var(--accent-glow); }
        .btn-primary:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 8px 32px var(--accent-glow); }
        .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-secondary { background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border); }
        .btn-secondary:hover { background: var(--border); }
        .toggle-section { margin-top: 20px; padding-top: 16px; border-top: 1px solid var(--border); }
        .toggle-row { display: flex; justify-content: space-between; align-items: center; }
        .toggle-info { flex: 1; }
        .toggle-title { font-size: 0.95rem; color: var(--text-primary); margin-bottom: 4px; }
        .toggle-desc { font-size: 0.8rem; color: var(--text-tertiary); }
        .toggle-switch { position: relative; width: 48px; height: 26px; flex-shrink: 0; margin-left: 16px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .toggle-slider { position: absolute; cursor: pointer; inset: 0; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 26px; transition: 0.2s; }
        .toggle-slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background: var(--text-tertiary); border-radius: 50%; transition: 0.2s; }
        .toggle-switch input:checked + .toggle-slider { background: var(--accent-dim); border-color: var(--accent); }
        .toggle-switch input:checked + .toggle-slider:before { transform: translateX(22px); background: var(--text-primary); }
        .log-section { margin-top: 24px; display: none; }
        .log-section.visible { display: block; }
        .log-title { font-size: 0.85rem; color: var(--text-tertiary); text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 12px; }
        .log-container { background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 8px; padding: 16px; max-height: 300px; overflow-y: auto; font-size: 0.8rem; line-height: 1.8; font-family: 'SF Mono', 'Consolas', 'Monaco', monospace; }
        .log-entry { color: var(--text-secondary); display: flex; gap: 8px; align-items: flex-start; }
        .log-entry.success { color: var(--accent); }
        .log-entry.error { color: var(--error); }
        .log-entry.warning { color: var(--warning); }
        .log-entry.info { color: var(--info); }
        .log-timestamp { color: var(--text-tertiary); font-size: 0.75rem; min-width: 52px; }
        .log-tag { font-size: 0.7rem; font-weight: 600; padding: 1px 6px; border-radius: 3px; text-transform: uppercase; min-width: 56px; text-align: center; }
        .log-tag.convert { background: #8b5cf620; color: #a78bfa; }
        .log-tag.split { background: #f59e0b20; color: #fbbf24; }
        .log-tag.fix { background: #22c55e20; color: #4ade80; }
        .log-tag.skip { background: #6b728020; color: #9ca3af; }
        .log-tag.info { background: #3b82f620; color: #60a5fa; }
        .log-tag.error { background: #ef444420; color: #f87171; }
        .log-tag.done { background: #10b98120; color: #34d399; }
        .log-message { flex: 1; }
        .log-detail { color: var(--text-tertiary); font-size: 0.75rem; }
        .log-summary { background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 8px; margin-top: 12px; overflow: hidden; }
        .log-summary-title { background: var(--bg-secondary); padding: 10px 14px; font-weight: 600; font-size: 0.85rem; border-bottom: 1px solid var(--border); color: var(--accent); }
        .log-summary-table { width: 100%; font-size: 0.8rem; }
        .log-summary-table td { padding: 8px 14px; border-bottom: 1px solid var(--border); }
        .log-summary-table tr:last-child td { border-bottom: none; }
        .log-summary-table td:first-child { color: var(--text-tertiary); width: 45%; }
        .log-summary-table td:last-child { color: var(--text-primary); font-weight: 500; text-align: right; }
        .log-summary-table .highlight { color: var(--accent); }
        .log-summary-table .saved { color: #4ade80; }
        .log-summary-table .increased { color: #fbbf24; }
        .image-picker { background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 12px; padding: 20px; margin-top: 24px; display: none; }
        .image-picker.visible { display: block; animation: slideUp 0.3s; }
        .image-picker-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
        .image-picker-title { font-size: 0.95rem; color: var(--text-secondary); display: flex; align-items: center; gap: 8px; }
        .image-picker-title span { font-size: 1.1rem; }
        .image-picker-count { font-size: 0.85rem; color: var(--accent); background: var(--bg-tertiary); padding: 4px 10px; border-radius: 12px; }
        .image-picker-actions { display: flex; gap: 8px; margin-bottom: 16px; }
        .image-picker-actions button { padding: 6px 12px; font-size: 0.8rem; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 6px; color: var(--text-secondary); cursor: pointer; transition: all 0.2s; }
        .image-picker-actions button:hover { background: var(--border); color: var(--text-primary); }
        .image-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 12px; max-height: 400px; overflow-y: auto; padding: 4px; }
        .image-thumb { position: relative; aspect-ratio: 1; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 8px; cursor: pointer; overflow: hidden; transition: all 0.2s; }
        .image-thumb:hover { border-color: var(--accent-dim); transform: scale(1.02); }
        .image-thumb.selected { border-color: var(--accent); box-shadow: 0 0 0 2px var(--accent-glow), 0 4px 12px var(--accent-glow); }
        .image-thumb img { width: 100%; height: 100%; object-fit: contain; padding: 4px; }
        .image-thumb-overlay { position: absolute; inset: 0; background: linear-gradient(to top, rgba(0,0,0,0.7) 0%, transparent 50%); opacity: 0; transition: opacity 0.2s; }
        .image-thumb:hover .image-thumb-overlay { opacity: 1; }
        .image-thumb.selected .image-thumb-overlay { opacity: 1; background: linear-gradient(to top, rgba(167,139,250,0.4) 0%, transparent 50%); }
        .image-thumb-info { position: absolute; bottom: 0; left: 0; right: 0; padding: 6px; font-size: 0.65rem; color: white; text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .image-thumb-badge { position: absolute; top: 6px; right: 6px; width: 22px; height: 22px; background: var(--accent); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 12px; opacity: 0; transform: scale(0.5); transition: all 0.2s; }
        .image-thumb.selected .image-thumb-badge { opacity: 1; transform: scale(1); }
        .image-thumb-dims { position: absolute; top: 6px; left: 6px; font-size: 0.6rem; background: rgba(0,0,0,0.6); color: white; padding: 2px 5px; border-radius: 4px; }
        .complete-section { text-align: center; padding: 32px; display: none; }
        .complete-section.visible { display: block; animation: slideUp 0.3s; }
        .complete-icon { font-size: 64px; margin-bottom: 16px; }
        .complete-title { font-size: 1.5rem; font-weight: 600; margin-bottom: 8px; }
        .complete-subtitle { color: var(--text-secondary); margin-bottom: 24px; }
        .buttons-row { display: flex; gap: 12px; margin-top: 24px; }
        .buttons-row .btn { flex: 1; margin-top: 0; }
        footer { text-align: center; margin-top: 48px; padding-top: 24px; border-top: 1px solid var(--border); color: var(--text-tertiary); font-size: 0.85rem; }
        footer a { color: var(--accent); text-decoration: none; }
        footer a:hover { text-decoration: underline; }
        .tech-note { background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 8px; padding: 16px; margin-top: 32px; font-size: 0.85rem; color: var(--text-secondary); }
        .tech-note strong { color: var(--text-primary); }
        .features-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-top: 12px; }
        .feature-item { display: flex; align-items: center; gap: 8px; font-size: 0.85rem; color: var(--text-secondary); }
        .feature-check { color: var(--accent); }
        .batch-info { background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 12px; padding: 16px; margin-top: 24px; display: none; }
        .batch-info.visible { display: block; animation: slideUp 0.3s; }
        .batch-header { display: flex; align-items: center; gap: 10px; margin-bottom: 12px; }
        .batch-icon { font-size: 1.3rem; }
        .batch-title { font-weight: 500; flex: 1; }
        .batch-count { color: var(--accent); font-size: 0.9rem; }
        .batch-list { display: flex; flex-direction: column; gap: 8px; max-height: 200px; overflow-y: auto; }
        .batch-item { display: flex; align-items: center; gap: 10px; padding: 10px 12px; background: var(--bg-tertiary); border-radius: 8px; font-size: 0.9rem; }
        .batch-item-name { flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .batch-item-status { font-size: 0.8rem; color: var(--text-tertiary); }
        .batch-item-status.done { color: var(--accent); }
        .batch-item-status.error { color: var(--error); }
        .batch-item-status.processing { color: var(--warning); }
        .batch-item-icon { width: 20px; text-align: center; }
        @media (max-width: 600px) { .stats-grid { grid-template-columns: repeat(2, 1fr); } .features-grid { grid-template-columns: 1fr; } }
        
        /* Advanced Mode Toggle */
        .mode-toggle { display: flex; align-items: center; justify-content: center; gap: 12px; margin-top: 16px; padding: 12px 16px; background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 8px; }
        .mode-toggle-label { font-size: 0.9rem; color: var(--text-secondary); cursor: pointer; display: flex; align-items: center; gap: 10px; user-select: none; }
        .mode-toggle-label:hover { color: var(--text-primary); }
        .mode-toggle .toggle-switch { margin: 0; }
        
        /* Simple mode: hide advanced elements */
        body:not(.advanced-mode) .stats-grid { display: none; }
        body:not(.advanced-mode) #validation-section { display: none !important; }
        body:not(.advanced-mode) #quality-section { display: none !important; }
        body:not(.advanced-mode) #image-picker { display: none !important; }
        body:not(.advanced-mode) #log-section { display: none !important; }
        body:not(.advanced-mode) .file-header { justify-content: center; }
        body:not(.advanced-mode) .file-icon { display: none; }
        
        /* Simple mode: simplified complete section */
        body:not(.advanced-mode) .complete-subtitle { display: none; }
    </style>
</head>
<body>
    <div class="grain"></div>
    <div class="container">
        <header>
            <div class="logo">
                <div class="logo-icon">üìö</div>
                <h1>Baseline JPEG Converter</h1>
            </div>
            <p class="subtitle">Convert EPUB images to baseline JPEG with SVG cover fix</p>
        </header>

        <div class="drop-zone" id="drop-zone">
            <span class="drop-zone-icon">üìÅ</span>
            <p class="drop-zone-text">Drop your EPUB files here</p>
            <p class="drop-zone-hint">or click to browse (multiple files supported)</p>
            <input type="file" id="file-input" accept=".epub" multiple>
        </div>

        <div class="mode-toggle">
            <label class="mode-toggle-label">
                <label class="toggle-switch">
                    <input type="checkbox" id="advanced-mode-toggle">
                    <span class="toggle-slider"></span>
                </label>
                <span>‚öôÔ∏è Advanced Mode</span>
            </label>
        </div>

        <div class="batch-info" id="batch-info">
            <div class="batch-header">
                <span class="batch-icon">üìö</span>
                <span class="batch-title">Batch Processing</span>
                <span class="batch-count" id="batch-count">0 files</span>
            </div>
            <div class="batch-list" id="batch-list"></div>
        </div>

        <div class="file-info" id="file-info">
            <div class="file-header">
                <div class="file-icon">üìñ</div>
                <span class="file-name" id="file-name">-</span>
                <span class="file-size" id="file-size">-</span>
            </div>
            <div class="stats-grid">
                <div class="stat-box"><div class="stat-value" id="stat-total">-</div><div class="stat-label">Images</div></div>
                <div class="stat-box"><div class="stat-value" id="stat-converted">-</div><div class="stat-label">Converted</div></div>
                <div class="stat-box"><div class="stat-value" id="stat-size">-</div><div class="stat-label">New Size</div></div>
                <div class="stat-box"><div class="stat-value" id="stat-saved">-</div><div class="stat-label">Saved</div></div>
            </div>
        </div>

        <div class="validation-section" id="validation-section">
            <div class="validation-header">
                <span class="validation-icon" id="validation-icon">üîç</span>
                <span class="validation-title" id="validation-title">Validating EPUB...</span>
            </div>
            <div class="validation-issues" id="validation-issues"></div>
        </div>

        <div class="quality-section" id="quality-section">
            <div class="quality-header">
                <span class="quality-label"><span>üé®</span> JPEG Quality</span>
                <div class="quality-input-wrapper">
                    <input type="number" class="quality-input" id="quality-input" min="1" max="95" value="85">
                    <span class="quality-percent">%</span>
                </div>
            </div>
            <input type="range" class="quality-slider" id="quality-slider" min="1" max="95" value="85">
            <div class="quality-hints"><span>Smaller file</span><span>Better quality</span></div>
            <div class="quality-presets">
                <button class="quality-preset" data-value="60">Low<br><small>60%</small></button>
                <button class="quality-preset" data-value="75">Medium<br><small>75%</small></button>
                <button class="quality-preset active" data-value="85">High<br><small>85%</small></button>
                <button class="quality-preset" data-value="95">Max<br><small>95%</small></button>
            </div>
            
            <div class="toggle-section">
                <div class="toggle-row">
                    <div class="toggle-info">
                        <div class="toggle-title">üîÑ Rotate & Split</div>
                        <div class="toggle-desc">Select images below to rotate 90¬∞ CW and split into multiple pages</div>
                    </div>
                    <span class="image-picker-count" id="split-count">0 selected</span>
                </div>
                <div class="toggle-row">
                    <div class="toggle-info">
                        <div class="toggle-title">‚ö´ Grayscale Images</div>
                        <div class="toggle-desc">Convert the cover and all images to grayscale</div>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="grayscale-toggle" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>
        </div>

        <div class="image-picker" id="image-picker">
            <div class="image-picker-header">
                <span class="image-picker-title"><span>üñºÔ∏è</span> Select Images to Rotate & Split</span>
                <span class="image-picker-count" id="picker-count">0 / 0 selected</span>
            </div>
            <div class="image-picker-actions">
                <button id="select-landscape-btn">Select Landscape</button>
                <button id="select-all-btn">Select All</button>
                <button id="select-none-btn">Clear Selection</button>
            </div>
            <div class="image-grid" id="image-grid"></div>
        </div>

        <div class="progress-section" id="progress-section">
            <div class="progress-bar-container"><div class="progress-bar" id="progress-bar"></div></div>
            <div class="progress-text"><span id="progress-status">Processing...</span><span id="progress-percent">0%</span></div>
        </div>

        <div class="log-section" id="log-section">
            <div class="log-title">Conversion Log</div>
            <div class="log-container" id="log-container"></div>
        </div>

        <button class="btn btn-primary" id="convert-btn" disabled><span>‚ö°</span> Convert to Baseline JPEG</button>

        <div class="complete-section" id="complete-section">
            <div class="complete-icon">‚úÖ</div>
            <h2 class="complete-title">Conversion Complete!</h2>
            <p class="complete-subtitle">All images converted to baseline JPEG format</p>
            <div class="buttons-row">
                <button class="btn btn-primary" id="download-btn"><span>‚¨áÔ∏è</span> Download EPUB</button>
                <button class="btn btn-secondary" id="reset-btn"><span>üîÑ</span> Convert Another</button>
            </div>
        </div>

        <div class="tech-note">
            <strong>What this does:</strong>
            <div class="features-grid">
                <div class="feature-item"><span class="feature-check">‚úì</span> Converts PNG/GIF/WebP/BMP ‚Üí baseline JPEG (1-95% quality)</div>
                <div class="feature-item"><span class="feature-check">‚úì</span> Scales images to fit e-reader screen (480√ó800 default)</div>
                <div class="feature-item"><span class="feature-check">‚úì</span> Rotate & Split: select images to rotate 90¬∞ CW and split into pages</div>
                <div class="feature-item"><span class="feature-check">‚úì</span> Grayscale conversion for e-ink displays</div>
                <div class="feature-item"><span class="feature-check">‚úì</span> Fixes SVG covers and SVG-wrapped images</div>
                <div class="feature-item"><span class="feature-check">‚úì</span> Repairs EPUB metadata (cover meta, manifest, NCX sync)</div>
                <div class="feature-item"><span class="feature-check">‚úì</span> Batch processing multiple EPUBs ‚Üí ZIP download</div>
                <div class="feature-item"><span class="feature-check">‚úì</span> Runs 100% in browser ‚Äî no upload to server</div>
            </div>
        </div>

        <footer>Made by <a href="#">Megabit & pablohc</a> ‚Ä¢ v2.6.0 ‚Ä¢ Runs entirely in your browser</footer>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        const $ = id => document.getElementById(id);
        const dropZone = $('drop-zone'), fileInput = $('file-input'), fileInfo = $('file-info');
        const fileName = $('file-name'), fileSize = $('file-size'), qualitySection = $('quality-section');
        const qualitySlider = $('quality-slider'), qualityInput = $('quality-input');
        const qualityPresets = document.querySelectorAll('.quality-preset');
        const convertBtn = $('convert-btn'), progressSection = $('progress-section');
        const progressBar = $('progress-bar'), progressStatus = $('progress-status'), progressPercent = $('progress-percent');
        const logSection = $('log-section'), logContainer = $('log-container');
        const completeSection = $('complete-section'), downloadBtn = $('download-btn'), resetBtn = $('reset-btn');
        const statTotal = $('stat-total'), statConverted = $('stat-converted'), statSize = $('stat-size'), statSaved = $('stat-saved');
        const validationSection = $('validation-section'), validationIcon = $('validation-icon');
        const validationTitle = $('validation-title'), validationIssues = $('validation-issues');
        const batchInfo = $('batch-info'), batchList = $('batch-list'), batchCount = $('batch-count');
        const imagePicker = $('image-picker'), imageGrid = $('image-grid');
        const pickerCount = $('picker-count'), splitCount = $('split-count');
        const selectLandscapeBtn = $('select-landscape-btn'), selectAllBtn = $('select-all-btn'), selectNoneBtn = $('select-none-btn');
        const advancedModeToggle = $('advanced-mode-toggle');

        let currentFile = null, convertedBlob = null, jpegQuality = 85, currentZip = null;
        let batchFiles = [], batchResults = [], isBatchMode = false;
        let enableGrayscale = true;    // toggle for grayscale conversion (default ON)
        let advancedMode = false;      // Advanced Mode off by default
        
        // Advanced Mode toggle handler
        advancedModeToggle.onchange = async () => {
            advancedMode = advancedModeToggle.checked;
            document.body.classList.toggle('advanced-mode', advancedMode);
            
            // If a file is already loaded, update UI accordingly
            if (currentZip && !isBatchMode) {
                if (advancedMode) {
                    // Switching to advanced: show quality section, run validation, load thumbnails
                    qualitySection.classList.add('visible');
                    
                    // Run validation and show results
                    validationSection.classList.remove('visible', 'success', 'warning', 'error');
                    validationIcon.textContent = 'üîç'; 
                    validationTitle.textContent = 'Validating EPUB...';
                    validationIssues.innerHTML = ''; 
                    validationSection.classList.add('visible');
                    
                    const result = await validateEpub(currentZip, false);
                    statTotal.textContent = result.imgCount;
                    showValidation(result, false);
                    
                    await loadImageThumbnails(currentZip);
                } else {
                    // Switching to simple: hide everything, clear selections
                    qualitySection.classList.remove('visible');
                    validationSection.classList.remove('visible');
                    imagePicker.classList.remove('visible');
                    selectedForSplit.clear();
                }
            } else if (isBatchMode && advancedMode) {
                qualitySection.classList.add('visible');
            } else if (isBatchMode && !advancedMode) {
                qualitySection.classList.remove('visible');
            }
        };
        
        // Image picker state
        let selectedForSplit = new Set();  // Set of image paths selected for Rotate & Split
        let imageMetadata = {};            // path -> {width, height, blobUrl}

        async function validateEpub(zip, isAfter = false) {
            const issues = [];
            const files = Object.keys(zip.files);
            
            // Check mimetype
            if (!files.includes('mimetype')) {
                issues.push({ type: 'error', msg: 'Missing mimetype file' });
            } else {
                const mt = await zip.file('mimetype').async('string');
                if (!mt.includes('application/epub+zip')) {
                    issues.push({ type: 'error', msg: 'Invalid mimetype content' });
                }
            }
            
            // Check container.xml
            if (!files.some(f => f.toLowerCase() === 'meta-inf/container.xml')) {
                issues.push({ type: 'error', msg: 'Missing META-INF/container.xml' });
            }
            
            // Find and check OPF
            const opfFile = files.find(f => f.toLowerCase().endsWith('.opf'));
            if (!opfFile) {
                issues.push({ type: 'error', msg: 'Missing OPF file' });
            } else {
                const opf = await zip.file(opfFile).async('string');
                
                // Check cover meta - support both attribute orders
                const coverMetaMatch = opf.match(/<meta\s+name=["']cover["']\s+content=["']([^"']+)["']/) ||
                                       opf.match(/<meta\s+content=["']([^"']+)["']\s+name=["']cover["']/);
                if (!coverMetaMatch) {
                    issues.push({ type: isAfter ? 'error' : 'warning', msg: 'Missing cover meta tag' + (isAfter ? '' : ' (will be added)') });
                } else {
                    const coverValue = coverMetaMatch[1];
                    // Check if value is a path (contains /) instead of just ID
                    if (coverValue.includes('/')) {
                        issues.push({ type: isAfter ? 'error' : 'warning', msg: 'Cover meta contains path instead of ID' + (isAfter ? '' : ' (will be fixed)') });
                    }
                }
                
                // Check for cover-image property
                if (!opf.includes('cover-image') && !opf.match(/id="[^"]*cover[^"]*"[^>]+media-type="image/i)) {
                    issues.push({ type: 'warning', msg: 'No cover image detected in manifest' });
                }
            }
            
            // Check for SVG image wrappers (including covers)
            let svgCovers = 0;
            for (const f of files) {
                if (f.toLowerCase().match(/\.(xhtml|html|htm)$/)) {
                    const content = await zip.file(f).async('string');
                    if (content.includes('<svg') && content.includes('xlink:href')) {
                        svgCovers++;
                    }
                }
            }
            if (svgCovers > 0) {
                issues.push({ type: isAfter ? 'error' : 'warning', msg: `${svgCovers} SVG image wrapper(s) detected` + (isAfter ? '' : ' (will be fixed)') });
            }
            
            // Check for non-baseline images
            let nonJpeg = 0, progressive = 0;
            for (const f of files) {
                const low = f.toLowerCase();
                if (low.match(/\.(png|gif|webp|bmp|jpeg)$/)) nonJpeg++;
            }
            if (nonJpeg > 0 && !isAfter) {
                issues.push({ type: 'info', msg: `${nonJpeg} non-JPEG image(s) will be converted` });
            }
            
            // Count images
            const imgCount = files.filter(f => f.toLowerCase().match(/\.(jpg|jpeg|png|gif|webp|bmp)$/)).length;
            
            return { issues, imgCount, svgCovers, nonJpeg };
        }

        function showValidation(result, isAfter = false) {
            validationSection.classList.remove('success', 'warning', 'error');
            validationIssues.innerHTML = '';
            
            const errors = result.issues.filter(i => i.type === 'error').length;
            const warnings = result.issues.filter(i => i.type === 'warning').length;
            
            if (errors > 0) {
                validationSection.classList.add('error');
                validationIcon.textContent = '‚ùå';
                validationTitle.textContent = isAfter ? `${errors} issue(s) remaining` : `${errors} error(s) found`;
            } else if (warnings > 0) {
                validationSection.classList.add('warning');
                validationIcon.textContent = '‚ö†Ô∏è';
                validationTitle.textContent = isAfter ? 'EPUB valid with warnings' : `${warnings} issue(s) will be fixed`;
            } else {
                validationSection.classList.add('success');
                validationIcon.textContent = '‚úÖ';
                validationTitle.textContent = isAfter ? 'EPUB valid - ready for e-readers' : 'EPUB structure valid';
            }
            
            result.issues.forEach(issue => {
                const div = document.createElement('div');
                div.className = 'validation-issue ' + issue.type;
                div.innerHTML = `<span>${issue.type === 'error' ? '‚úó' : issue.type === 'warning' ? '‚ö†' : issue.type === 'success' ? '‚úì' : '‚Ñπ'}</span> ${issue.msg}`;
                validationIssues.appendChild(div);
            });
            
            if (result.issues.length === 0) {
                const div = document.createElement('div');
                div.className = 'validation-issue success';
                div.innerHTML = '<span>‚úì</span> All checks passed';
                validationIssues.appendChild(div);
            }
            
            validationSection.classList.add('visible');
        }

        qualitySlider.oninput = e => { jpegQuality = +e.target.value; qualityInput.value = jpegQuality; updatePresets(); };
        qualityInput.oninput = e => { let v = Math.max(1, Math.min(95, +e.target.value || 85)); jpegQuality = v; qualitySlider.value = v; updatePresets(); };
        qualityInput.onblur = () => qualityInput.value = jpegQuality;
        qualityPresets.forEach(b => b.onclick = () => { jpegQuality = +b.dataset.value; qualitySlider.value = qualityInput.value = jpegQuality; updatePresets(); });
        function updatePresets() { qualityPresets.forEach(b => b.classList.toggle('active', +b.dataset.value === jpegQuality)); }
        
        // Image picker functions
        function updatePickerCount() {
            const total = Object.keys(imageMetadata).length;
            const selected = selectedForSplit.size;
            pickerCount.textContent = `${selected} / ${total} selected`;
            splitCount.textContent = `${selected} selected`;
        }
        
        function toggleImageSelection(path) {
            if (selectedForSplit.has(path)) {
                selectedForSplit.delete(path);
            } else {
                selectedForSplit.add(path);
            }
            // Update thumbnail visual state
            const thumb = document.querySelector(`.image-thumb[data-path="${CSS.escape(path)}"]`);
            if (thumb) {
                thumb.classList.toggle('selected', selectedForSplit.has(path));
            }
            updatePickerCount();
        }
        
        async function loadImageThumbnails(zip) {
            imageGrid.innerHTML = '';
            selectedForSplit.clear();
            imageMetadata = {};
            
            // Get all images in the EPUB
            const allImages = new Set();
            zip.forEach(p => { 
                if (p.toLowerCase().match(/\.(png|gif|webp|bmp|jpg|jpeg)$/)) allImages.add(p); 
            });
            
            // Try to get images in reading order from OPF spine
            let orderedImages = [];
            try {
                // Find OPF file
                let opfPath = null;
                zip.forEach(p => { if (p.toLowerCase().endsWith('.opf')) opfPath = p; });
                
                if (opfPath) {
                    const opfContent = await zip.files[opfPath].async('string');
                    const opfDir = opfPath.includes('/') ? opfPath.substring(0, opfPath.lastIndexOf('/')) : '';
                    
                    // Parse manifest to get id -> href mapping
                    const manifest = {};
                    const manifestRegex = /<item[^>]+id=["']([^"']+)["'][^>]+href=["']([^"']+)["'][^>]*>/gi;
                    let match;
                    while ((match = manifestRegex.exec(opfContent)) !== null) {
                        const id = match[1];
                        const href = match[2];
                        const fullPath = opfDir ? opfDir + '/' + href : href;
                        manifest[id] = fullPath;
                    }
                    // Also check reversed attribute order
                    const manifestRegex2 = /<item[^>]+href=["']([^"']+)["'][^>]+id=["']([^"']+)["'][^>]*>/gi;
                    while ((match = manifestRegex2.exec(opfContent)) !== null) {
                        const href = match[1];
                        const id = match[2];
                        const fullPath = opfDir ? opfDir + '/' + href : href;
                        manifest[id] = fullPath;
                    }
                    
                    // Parse spine to get reading order
                    const spineOrder = [];
                    const spineRegex = /<itemref[^>]+idref=["']([^"']+)["'][^>]*>/gi;
                    while ((match = spineRegex.exec(opfContent)) !== null) {
                        const idref = match[1];
                        if (manifest[idref]) spineOrder.push(manifest[idref]);
                    }
                    
                    // For each spine item (XHTML), extract images in order
                    const seenImages = new Set();
                    for (const xhtmlPath of spineOrder) {
                        if (!zip.files[xhtmlPath]) continue;
                        const xhtmlContent = await zip.files[xhtmlPath].async('string');
                        const xhtmlDir = xhtmlPath.includes('/') ? xhtmlPath.substring(0, xhtmlPath.lastIndexOf('/')) : '';
                        
                        // Find all image references
                        const imgRegex = /(?:src|xlink:href)=["']([^"']+)["']/gi;
                        while ((match = imgRegex.exec(xhtmlContent)) !== null) {
                            let imgHref = match[1];
                            // Resolve relative path
                            let imgPath;
                            if (imgHref.startsWith('../')) {
                                // Go up from xhtmlDir
                                const parts = xhtmlDir.split('/');
                                parts.pop();
                                imgPath = parts.join('/') + '/' + imgHref.substring(3);
                            } else if (imgHref.startsWith('/')) {
                                imgPath = imgHref.substring(1);
                            } else {
                                imgPath = xhtmlDir ? xhtmlDir + '/' + imgHref : imgHref;
                            }
                            // Normalize path
                            imgPath = imgPath.replace(/\/+/g, '/');
                            
                            // Check if this is actually an image in our list
                            for (const realPath of allImages) {
                                if (realPath === imgPath || realPath.endsWith('/' + imgHref) || realPath.endsWith(imgHref)) {
                                    if (!seenImages.has(realPath)) {
                                        seenImages.add(realPath);
                                        orderedImages.push(realPath);
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    
                    // Add any remaining images that weren't in XHTML files (e.g., unused images)
                    for (const imgPath of allImages) {
                        if (!seenImages.has(imgPath)) {
                            orderedImages.push(imgPath);
                        }
                    }
                }
            } catch (e) {
                console.warn('Failed to parse reading order, using default:', e);
            }
            
            // Fallback to alphabetical if parsing failed
            if (orderedImages.length === 0) {
                orderedImages = [...allImages].sort();
            }
            
            // Load thumbnails in order
            for (const path of orderedImages) {
                try {
                    const data = await zip.files[path].async('arraybuffer');
                    const blob = new Blob([data]);
                    const blobUrl = URL.createObjectURL(blob);
                    
                    // Get image dimensions
                    const dimensions = await new Promise((resolve) => {
                        const img = new Image();
                        img.onload = () => resolve({ width: img.width, height: img.height });
                        img.onerror = () => resolve({ width: 0, height: 0 });
                        img.src = blobUrl;
                    });
                    
                    imageMetadata[path] = { ...dimensions, blobUrl };
                    
                    // Create thumbnail element
                    const thumb = document.createElement('div');
                    thumb.className = 'image-thumb';
                    thumb.dataset.path = path;
                    thumb.innerHTML = `
                        <img src="${blobUrl}" alt="${path.split('/').pop()}">
                        <div class="image-thumb-dims">${dimensions.width}√ó${dimensions.height}</div>
                        <div class="image-thumb-overlay"></div>
                        <div class="image-thumb-info">${path.split('/').pop()}</div>
                        <div class="image-thumb-badge">‚úì</div>
                    `;
                    thumb.onclick = () => toggleImageSelection(path);
                    imageGrid.appendChild(thumb);
                } catch (e) {
                    console.warn('Failed to load thumbnail:', path, e);
                }
            }
            
            updatePickerCount();
            imagePicker.classList.add('visible');
        }
        
        // Image picker action buttons
        selectLandscapeBtn.onclick = () => {
            for (const [path, meta] of Object.entries(imageMetadata)) {
                if (meta.width > meta.height) {
                    selectedForSplit.add(path);
                    const thumb = document.querySelector(`.image-thumb[data-path="${CSS.escape(path)}"]`);
                    if (thumb) thumb.classList.add('selected');
                }
            }
            updatePickerCount();
        };
        
        selectAllBtn.onclick = () => {
            for (const path of Object.keys(imageMetadata)) {
                selectedForSplit.add(path);
                const thumb = document.querySelector(`.image-thumb[data-path="${CSS.escape(path)}"]`);
                if (thumb) thumb.classList.add('selected');
            }
            updatePickerCount();
        };
        
        selectNoneBtn.onclick = () => {
            selectedForSplit.clear();
            document.querySelectorAll('.image-thumb.selected').forEach(t => t.classList.remove('selected'));
            updatePickerCount();
        };

        const grayscaleToggle = document.getElementById('grayscale-toggle');
        if (grayscaleToggle) {
            enableGrayscale = grayscaleToggle.checked;
            grayscaleToggle.onchange = () => { enableGrayscale = grayscaleToggle.checked; };
        }

        function formatBytes(b) { if (!b) return '0 B'; const k = 1024, s = ['B','KB','MB','GB'], i = Math.floor(Math.log(b)/Math.log(k)); return (b/Math.pow(k,i)).toFixed(1)+' '+s[i]; }
        
        // Enhanced logging system
        let logStartTime = null;
        let conversionStats = { images: 0, splits: 0, splitParts: 0, fixes: 0, skipped: 0, errors: 0, originalSize: 0, newSize: 0 };
        
        function getTimestamp() {
            if (!logStartTime) return '[00:00.0]';
            const elapsed = (Date.now() - logStartTime) / 1000;
            const mins = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const secs = (elapsed % 60).toFixed(1).padStart(4, '0');
            return `[${mins}:${secs}]`;
        }
        
        function log(message, type = '', tag = '') {
            const entry = document.createElement('div');
            entry.className = 'log-entry ' + type;
            
            // Timestamp
            const timestamp = document.createElement('span');
            timestamp.className = 'log-timestamp';
            timestamp.textContent = getTimestamp();
            entry.appendChild(timestamp);
            
            // Tag (if provided)
            if (tag) {
                const tagEl = document.createElement('span');
                tagEl.className = 'log-tag ' + tag.toLowerCase();
                tagEl.textContent = tag;
                entry.appendChild(tagEl);
            }
            
            // Message
            const msg = document.createElement('span');
            msg.className = 'log-message';
            msg.innerHTML = message;
            entry.appendChild(msg);
            
            logContainer.appendChild(entry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }
        
        function logImage(name, origW, origH, origFormat, origSize, newW, newH, newSize, wasSplit = false, splitCount = 0, partsInfo = null) {
            const saved = origSize - newSize;
            const savedPct = ((saved / origSize) * 100).toFixed(0);
            const dims = `${origW}√ó${origH}`;
            const newDims = `${newW}√ó${newH}`;
            
            if (wasSplit) {
                conversionStats.splits++;
                conversionStats.splitParts += splitCount;
                if (advancedMode) {
                    // Build parts detail string
                    let partsDetail = '';
                    if (partsInfo && partsInfo.length > 0) {
                        partsDetail = partsInfo.map(p => 
                            `${p.name} (${p.width}√ó${p.height}, ${formatBytes(p.size)})`
                        ).join(', ');
                    }
                    const savedInfo = saved > 0 ? `, <span style="color:#4ade80">-${savedPct}%</span>` : '';
                    log(`<strong>${name}</strong> <span class="log-detail">(${dims} ${origFormat.toUpperCase()}, ${formatBytes(origSize)}) ‚Üí ${splitCount} parts${savedInfo}</span>`, '', 'SPLIT');
                    if (partsDetail) {
                        log(`<span class="log-detail" style="margin-left: 20px;">‚Ü≥ ${partsDetail}</span>`, '', '');
                    }
                }
            } else {
                conversionStats.images++;
                if (advancedMode) {
                    const detail = saved > 0 
                        ? `<span class="log-detail">(${dims} ‚Üí ${newDims}, ${formatBytes(origSize)} ‚Üí ${formatBytes(newSize)}, <span style="color:#4ade80">-${savedPct}%</span>)</span>`
                        : `<span class="log-detail">(${dims} ‚Üí ${newDims}, ${formatBytes(newSize)})</span>`;
                    log(`<strong>${name}</strong> ${detail}`, '', 'CONVERT');
                }
            }
        }
        
        function logFix(type, detail) {
            conversionStats.fixes++;
            if (advancedMode) log(`${type}: <span class="log-detail">${detail}</span>`, 'success', 'FIX');
        }
        
        function logSkip(name, reason) {
            conversionStats.skipped++;
            if (advancedMode) log(`${name} <span class="log-detail">(${reason})</span>`, '', 'SKIP');
        }
        
        function logError(message) {
            conversionStats.errors++;
            if (advancedMode) log(message, 'error', 'ERROR');
        }
        
        function logSummary(originalSize, newSize, timeElapsed) {
            if (!advancedMode) return;
            
            const saved = originalSize - newSize;
            const savedPct = ((saved / originalSize) * 100).toFixed(1);
            const totalImages = conversionStats.images + conversionStats.splits;
            const totalOutput = conversionStats.images + conversionStats.splitParts;
            
            const summaryHtml = `
                <div class="log-summary">
                    <div class="log-summary-title">üìä Conversion Summary</div>
                    <table class="log-summary-table">
                        <tr><td>Images processed</td><td class="highlight">${totalImages}${conversionStats.splits > 0 ? ` (${conversionStats.splits} split ‚Üí ${conversionStats.splitParts} parts)` : ''}</td></tr>
                        <tr><td>Output images</td><td>${totalOutput}</td></tr>
                        <tr><td>EPUB repairs</td><td>${conversionStats.fixes > 0 ? conversionStats.fixes + ' fixes applied' : 'None needed'}</td></tr>
                        ${conversionStats.errors > 0 ? `<tr><td>Errors</td><td style="color:#f87171">${conversionStats.errors}</td></tr>` : ''}
                        <tr><td>Original size</td><td>${formatBytes(originalSize)}</td></tr>
                        <tr><td>New size</td><td>${formatBytes(newSize)}</td></tr>
                        <tr><td>Saved</td><td class="${saved > 0 ? 'saved' : 'increased'}">${saved > 0 ? formatBytes(saved) + ' (' + savedPct + '%)' : '+' + formatBytes(-saved)}</td></tr>
                        <tr><td>Time</td><td>${timeElapsed.toFixed(1)}s</td></tr>
                    </table>
                </div>
            `;
            logContainer.insertAdjacentHTML('beforeend', summaryHtml);
            logContainer.scrollTop = logContainer.scrollHeight;
        }
        
        function clearLog() { 
            logContainer.innerHTML = ''; 
            logStartTime = Date.now();
            conversionStats = { images: 0, splits: 0, splitParts: 0, fixes: 0, skipped: 0, errors: 0, originalSize: 0, newSize: 0 };
        }
        function progress(p, s) { progressBar.style.width = p+'%'; progressPercent.textContent = Math.round(p)+'%'; if (s) progressStatus.textContent = s; }

        dropZone.onclick = () => fileInput.click();
        dropZone.ondragover = e => { e.preventDefault(); dropZone.classList.add('drag-over'); };
        dropZone.ondragleave = () => dropZone.classList.remove('drag-over');
        dropZone.ondrop = e => { 
            e.preventDefault(); 
            dropZone.classList.remove('drag-over'); 
            const files = [...e.dataTransfer.files].filter(f => f.name.endsWith('.epub'));
            if (files.length > 0) handleFiles(files);
        };
        fileInput.onchange = e => { 
            const files = [...e.target.files].filter(f => f.name.endsWith('.epub'));
            if (files.length > 0) handleFiles(files);
        };

        function updateBatchList() {
            batchList.innerHTML = '';
            batchFiles.forEach((f, i) => {
                const status = batchResults[i];
                const item = document.createElement('div');
                item.className = 'batch-item';
                let icon = 'üìÑ', statusText = 'Pending', statusClass = '';
                if (status === 'processing') { icon = '‚è≥'; statusText = 'Processing...'; statusClass = 'processing'; }
                else if (status === 'done') { icon = '‚úÖ'; statusText = 'Done'; statusClass = 'done'; }
                else if (status === 'error') { icon = '‚ùå'; statusText = 'Error'; statusClass = 'error'; }
                item.innerHTML = `<span class="batch-item-icon">${icon}</span><span class="batch-item-name">${f.name}</span><span class="batch-item-status ${statusClass}">${statusText}</span>`;
                batchList.appendChild(item);
            });
            batchCount.textContent = `${batchFiles.length} file${batchFiles.length > 1 ? 's' : ''}`;
        }

        async function handleFiles(files) {
            if (files.length === 1) {
                // Single file mode
                isBatchMode = false;
                batchInfo.classList.remove('visible');
                handleFile(files[0]);
            } else {
                // Batch mode
                isBatchMode = true;
                batchFiles = files;
                batchResults = files.map(() => 'pending');
                batchInfo.classList.add('visible');
                fileInfo.classList.remove('visible');
                validationSection.classList.remove('visible');
                imagePicker.classList.remove('visible');
                // Clean up any previous image picker state
                for (const meta of Object.values(imageMetadata)) {
                    if (meta.blobUrl) URL.revokeObjectURL(meta.blobUrl);
                }
                selectedForSplit.clear();
                imageMetadata = {};
                imageGrid.innerHTML = '';
                updateBatchList();
                if (advancedMode) {
                    qualitySection.classList.add('visible');
                }
                convertBtn.disabled = false;
            }
        }

        async function handleFile(f) {
            currentFile = f; fileName.textContent = f.name; fileSize.textContent = formatBytes(f.size);
            fileInfo.classList.add('visible'); 
            imagePicker.classList.remove('visible');
            completeSection.classList.remove('visible'); 
            statTotal.textContent = statConverted.textContent = statSize.textContent = statSaved.textContent = '-'; 
            clearLog();
            
            try {
                currentZip = await JSZip.loadAsync(f);
                
                if (advancedMode) {
                    // Advanced mode: show validation, quality settings, image picker
                    validationSection.classList.remove('visible', 'success', 'warning', 'error');
                    validationIcon.textContent = 'üîç'; validationTitle.textContent = 'Validating EPUB...';
                    validationIssues.innerHTML = ''; validationSection.classList.add('visible');
                    
                    const result = await validateEpub(currentZip, false);
                    statTotal.textContent = result.imgCount;
                    showValidation(result, false);
                    qualitySection.classList.add('visible');
                    
                    // Load image thumbnails for Rotate & Split selection
                    await loadImageThumbnails(currentZip);
                } else {
                    // Simple mode: just validate silently, use defaults
                    validationSection.classList.remove('visible');
                    qualitySection.classList.remove('visible');
                    await validateEpub(currentZip, false); // validate but don't show
                }
                
                convertBtn.disabled = false;
            } catch (e) {
                if (advancedMode) {
                    validationSection.classList.add('error');
                    validationIcon.textContent = '‚ùå';
                    validationTitle.textContent = 'Invalid EPUB file';
                    validationIssues.innerHTML = '<div class="validation-issue error"><span>‚úó</span> ' + e.message + '</div>';
                } else {
                    alert('Invalid EPUB file: ' + e.message);
                }
                convertBtn.disabled = true;
            }
        }

        function fixSvgCover(c) {
            if (!c.includes('<svg') || !c.includes('xlink:href')) return { c, fixed: false, count: 0 };
            if (!c.includes('calibre:cover') && !c.includes('name="cover"') && !c.includes('<title>Cover</title>')) return { c, fixed: false, count: 0 };
            const m = c.match(/xlink:href=["']([^"']+)["']/); if (!m) return { c, fixed: false, count: 0 };
            return { c: `<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head><meta content="text/html; charset=UTF-8" http-equiv="default-style"/><title>Cover</title></head>
<body><section epub:type="cover"><img alt="Cover" src="${m[1]}"/></section></body>
</html>`, fixed: true, count: 1 };
        }

        // General fixer: unwrap any SVG-wrapped raster <image> into a plain <img>
        function fixSvgWrappedImages(c) {
            if (!c.includes('<svg') || !c.includes('xlink:href')) return { c, fixed: false, count: 0 };
            let fixedCount = 0;
            const svgImageRegex = /<svg\b[^>]*>[\s\S]*?<image\b[^>]*xlink:href=["']([^"']+)["'][^>]*>[\s\S]*?<\/svg>/gi;
            
            const newContent = c.replace(svgImageRegex, (match, href) => {
                fixedCount++;
                // Try to preserve width/height from <image> first, then <svg>
                const imageTagMatch = match.match(/<image\b[^>]*>/i);
                const svgTagMatch = match.match(/<svg\b[^>]*>/i);
                
                const getDim = (tag, attr) => {
                    if (!tag) return null;
                    const m = tag.match(new RegExp(attr + '=["\']([^"\']+)["\']', 'i'));
                    return m ? m[1] : null;
                };
                
                let width = getDim(imageTagMatch && imageTagMatch[0], 'width') || getDim(svgTagMatch && svgTagMatch[0], 'width');
                let height = getDim(imageTagMatch && imageTagMatch[0], 'height') || getDim(svgTagMatch && svgTagMatch[0], 'height');
                
                let attrs = '';
                if (width) attrs += ` width="${width}"`;
                if (height) attrs += ` height="${height}"`;
                
                return `<img src="${href}" alt=""${attrs} />`;
            });
            
            return { c: newContent, fixed: fixedCount > 0, count: fixedCount };
        }

        function ensureCoverMeta(o) {
            // Find cover image ID from manifest
            // Handles namespaces and any attribute order.
            let coverId = null, m;

            // Try 1: properties="cover-image" (with namespace support)
            if (!coverId && (m = o.match(/<\w+:?item[^>]+id="([^"]+)"[^>]+properties="[^"]*cover-image[^"]*"/i))) coverId = m[1];
            if (!coverId && (m = o.match(/<\w+:?item[^>]+properties="[^"]*cover-image[^"]*"[^>]+id="([^"]+)"/i))) coverId = m[1];

            // Try 2: href contains "cover" and is an image (any attribute order)
            if (!coverId && (m = o.match(/<\w+:?item[^>]*id="([^"]+)"[^>]*href="[^"]*cover[^"]*"[^>]*media-type="image\//i))) coverId = m[1];
            if (!coverId && (m = o.match(/<\w+:?item[^>]*href="[^"]*cover[^"]*"[^>]*id="([^"]+)"[^>]*media-type="image\//i))) coverId = m[1];

            // Try 3: id contains "cover" and is an image (any attribute order with namespace)
            if (!coverId && (m = o.match(/<\w+:?item[^>]*id="([^"]*cover[^"]*)"[^>]*media-type="image\//i))) coverId = m[1];
            if (!coverId && (m = o.match(/<\w+:?item[^>]*media-type="image\/[^"]*"[^>]*id="([^"]*cover[^"]*)"/i))) coverId = m[1];

            if (!coverId) return { o, fixed: false };

            // Check if cover meta exists (handle namespaces like opf:meta)
            const metaMatch = o.match(/<\w+:?meta\s+name=["']cover["']\s+content=["']([^"']+)["']/i) ||
                              o.match(/<\w+:?meta\s+content=["']([^"']+)["']\s+name=["']cover["']/i);

            if (metaMatch) {
                const currentValue = metaMatch[1];
                if (currentValue.includes('/') || currentValue !== coverId) {
                    // Fix incorrect cover meta (handle namespaces)
                    o = o.replace(/<\w+:?meta\s+name=["']cover["']\s+content=["'][^"']+["']\s*\/?>/gi, `<meta name="cover" content="${coverId}" />`);
                    o = o.replace(/<\w+:?meta\s+content=["'][^"']+["']\s+name=["']cover["']\s*\/?>/gi, `<meta name="cover" content="${coverId}" />`);
                    return { o, fixed: true };
                }
                return { o, fixed: false };
            }

            // Add missing cover meta
            const idx = o.indexOf('</metadata>');
            if (idx !== -1) {
                return { o: o.substring(0, idx) + `    <meta name="cover" content="${coverId}"/>\n  </metadata>` + o.substring(idx + 11), fixed: true };
            }

            return { o, fixed: false };
        }

        const MAX_WIDTH = 480;
        const MAX_HEIGHT = 800;
        const OVERLAP = 0.15; // 15% overlap

        function applyGrayscale(ctx, width, height) {
            if (!enableGrayscale) return;
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const l = 0.2126 * r + 0.7152 * g + 0.0722 * b;
                data[i] = data[i + 1] = data[i + 2] = l;
            }
            ctx.putImageData(imageData, 0, 0);
        }

        // Process image: returns array of {data, suffix} objects
        async function processImage(data, imagePath = '') {
            return new Promise((resolve, reject) => {
                const url = URL.createObjectURL(new Blob([data]));
                const img = new Image();
                img.onload = async () => {
                    URL.revokeObjectURL(url);
                    const origW = img.width, origH = img.height;
                    const origSize = data.byteLength;
                    const origFormat = 'image'; // Will be refined by caller based on extension
                    
                    // Check if this image is selected for Rotate & Split (manual selection)
                    const applyRotateSplit = selectedForSplit.has(imagePath);
                    
                    if (applyRotateSplit) {
                        // LIGHT NOVEL MODE: Rotate 90¬∞ CW and split if needed
                        //
                        // Step 1: Scale WIDTH to 800px (keep aspect ratio)
                        // Step 2: Rotate 90¬∞ clockwise  
                        // Step 3: If WIDTH > 480, split vertically with 15% overlap
                        
                        // Step 1: Scale width to 800
                        const scale = MAX_HEIGHT / origW;  // 800 / origW
                        const scaledW = MAX_HEIGHT;  // 800
                        const scaledH = Math.round(origH * scale);
                        
                        const scaledCanvas = document.createElement('canvas');
                        scaledCanvas.width = scaledW;
                        scaledCanvas.height = scaledH;
                        const scaledCtx = scaledCanvas.getContext('2d');
                        scaledCtx.imageSmoothingEnabled = true;
                        scaledCtx.imageSmoothingQuality = 'high';
                        scaledCtx.fillStyle = '#FFF';
                        scaledCtx.fillRect(0, 0, scaledW, scaledH);
                        scaledCtx.drawImage(img, 0, 0, origW, origH, 0, 0, scaledW, scaledH);
                        
                        // Step 2: Rotate 90¬∞ CW
                        // After rotation: new width = scaledH, new height = scaledW (800)
                        const rotW = scaledH;
                        const rotH = scaledW;  // 800
                        
                        const rotCanvas = document.createElement('canvas');
                        rotCanvas.width = rotW;
                        rotCanvas.height = rotH;
                        const rotCtx = rotCanvas.getContext('2d');
                        rotCtx.fillStyle = '#FFF';
                        rotCtx.fillRect(0, 0, rotW, rotH);
                        rotCtx.translate(rotW, 0);
                        rotCtx.rotate(Math.PI / 2);
                        rotCtx.drawImage(scaledCanvas, 0, 0);
                        applyGrayscale(rotCtx, rotW, rotH);
                        
                        // Step 3: If WIDTH > 480, split vertically
                        if (rotW <= MAX_WIDTH) {
                            // No split needed - width fits
                            const blob = await new Promise(res => rotCanvas.toBlob(res, 'image/jpeg', jpegQuality/100));
                            const arrBuf = await blob.arrayBuffer();
                            resolve({ 
                                parts: [{ data: arrBuf, suffix: '', width: rotW, height: rotH }],
                                meta: { origW, origH, origSize, wasSplit: false, rotated: true }
                            });
                        } else {
                            // Split by WIDTH (vertical cuts) - from RIGHT to LEFT
                            // After 90¬∞ CW rotation: right side becomes top, left becomes bottom
                            // So we cut from right to left to get top-to-bottom order
                            const parts = [];
                            const maxW = MAX_WIDTH;  // 480
                            const overlapPx = Math.round(maxW * OVERLAP);  // ~72
                            const step = maxW - overlapPx;  // ~408
                            const numParts = Math.ceil((rotW - overlapPx) / step);
                            
                            for (let i = 0; i < numParts; i++) {
                                // Start from right side (rotW) and go left
                                let x = rotW - maxW - (i * step);
                                if (i === numParts - 1) {
                                    x = 0;  // Last part starts at left edge
                                }
                                x = Math.max(0, x);
                                const partW = Math.min(maxW, rotW - x);
                                
                                const partCanvas = document.createElement('canvas');
                                partCanvas.width = partW;
                                partCanvas.height = rotH;  // 800
                                const partCtx = partCanvas.getContext('2d');
                                partCtx.drawImage(rotCanvas, x, 0, partW, rotH, 0, 0, partW, rotH);
                                
                                const blob = await new Promise(res => partCanvas.toBlob(res, 'image/jpeg', jpegQuality/100));
                                const arrBuf = await blob.arrayBuffer();
                                parts.push({ data: arrBuf, suffix: `_part${i + 1}`, width: partW, height: rotH });
                            }
                            resolve({ 
                                parts,
                                meta: { origW, origH, origSize, wasSplit: true, splitCount: numParts, rotated: true }
                            });
                        }
                    } else {
                        // NOT rotating - check if we need to scale at all
                        const fitsInScreen = origW <= MAX_WIDTH && origH <= MAX_HEIGHT;
                        
                        if (fitsInScreen) {
                            // Image already fits in 480x800 - don't touch it, just convert to JPEG
                            const c = document.createElement('canvas');
                            c.width = origW;
                            c.height = origH;
                            const ctx = c.getContext('2d');
                            ctx.fillStyle = '#FFF';
                            ctx.fillRect(0, 0, origW, origH);
                            ctx.drawImage(img, 0, 0);
                            applyGrayscale(ctx, origW, origH);

                            const blob = await new Promise(res => c.toBlob(res, 'image/jpeg', jpegQuality/100));
                            const arrBuf = await blob.arrayBuffer();
                            resolve({ 
                                parts: [{ data: arrBuf, suffix: '', width: origW, height: origH }],
                                meta: { origW, origH, origSize, wasSplit: false, scaled: false }
                            });
                        } else {
                            // Image too big - scale to fit 480x800 (keep aspect ratio)
                            const scale = Math.min(MAX_WIDTH / origW, MAX_HEIGHT / origH);
                            const newW = Math.round(origW * scale);
                            const newH = Math.round(origH * scale);
                            
                            const c = document.createElement('canvas');
                            c.width = newW;
                            c.height = newH;
                            const ctx = c.getContext('2d');
                            ctx.imageSmoothingEnabled = true;
                            ctx.imageSmoothingQuality = 'high';
                            ctx.fillStyle = '#FFF';
                            ctx.fillRect(0, 0, newW, newH);
                            ctx.drawImage(img, 0, 0, newW, newH);
                            applyGrayscale(ctx, newW, newH);

                            const blob = await new Promise(res => c.toBlob(res, 'image/jpeg', jpegQuality/100));
                            const arrBuf = await blob.arrayBuffer();
                            resolve({ 
                                parts: [{ data: arrBuf, suffix: '', width: newW, height: newH }],
                                meta: { origW, origH, origSize, wasSplit: false, scaled: true, newW, newH }
                            });
                        }
                    }
                };
                img.onerror = () => { URL.revokeObjectURL(url); reject(new Error('Load failed')); };
                img.src = url;
            });
        }

        // Convert single file and return blob
        async function convertSingleFile(file, progressCallback) {
            const zip = await JSZip.loadAsync(file);
            const renamed = {};
            zip.forEach(p => { const l = p.toLowerCase(); if (l.match(/\.(png|gif|webp|bmp|jpeg)$/)) renamed[p] = p.replace(/\.(png|gif|webp|bmp|jpeg)$/i, '.jpg'); });
            const imgs = []; zip.forEach(p => { if (p.toLowerCase().match(/\.(png|gif|webp|bmp|jpg|jpeg)$/)) imgs.push(p); });

            let conv = 0, svgFix = 0, splitCount = 0;
            const out = new JSZip(), entries = Object.entries(zip.files);
            const splitImages = {};
            const xhtmlFiles = {};
            let opfPath = null, opfContent = null;
            
            // CRITICAL: Write mimetype FIRST per EPUB OCF spec
            // It must be uncompressed and the first entry in the archive
            if (zip.files['mimetype']) {
                const mimetypeData = await zip.files['mimetype'].async('arraybuffer');
                out.file('mimetype', mimetypeData, { compression: 'STORE', createFolders: false });
            }
            
            // First pass: process images
            for (let i = 0; i < entries.length; i++) {
                const [path, fileObj] = entries[i];
                if (fileObj.dir || path === 'mimetype') continue;
                const low = path.toLowerCase();
                
                if (low.match(/\.(png|gif|webp|bmp|jpg|jpeg)$/)) {
                    const data = await fileObj.async('arraybuffer');
                    const result = await processImage(data, path);
                    const { parts } = result;
                    
                    const baseName = path.replace(/\.[^.]+$/, '');
                    const newExt = '.jpg';
                    
                    if (parts.length === 1 && parts[0].suffix === '') {
                        const newPath = renamed[path] || path.replace(/\.[^.]+$/, newExt);
                        out.file(newPath, parts[0].data, { compression: 'DEFLATE', createFolders: false });
                        conv++;
                    } else {
                        // Use full path as key to avoid collisions with same-named files in different folders
                        const splitKey = path;
                        splitImages[splitKey] = [];
                        
                        for (const part of parts) {
                            const partName = baseName.split('/').pop() + part.suffix + newExt;
                            const partPath = (path.includes('/') ? path.substring(0, path.lastIndexOf('/') + 1) : '') + partName;
                            out.file(partPath, part.data, { compression: 'DEFLATE', createFolders: false });
                            splitImages[splitKey].push({ 
                                path: partPath, 
                                imgName: partName,
                                id: baseName.split('/').pop() + part.suffix,
                                suffix: part.suffix
                            });
                            splitCount++;
                            conv++;
                        }
                    }
                } else if (low.match(/\.(xhtml|html|htm)$/)) {
                    xhtmlFiles[path] = await fileObj.async('string');
                } else if (low.endsWith('.opf')) {
                    opfPath = path;
                    opfContent = await fileObj.async('string');
                }
                
                if (progressCallback) progressCallback((i / entries.length) * 60);
            }
            
            // Second pass: update XHTML
            for (const [path, content] of Object.entries(xhtmlFiles)) {
                let t = content;
                const r = fixSvgCover(t);
                if (r.fixed) { t = r.c; svgFix += r.count || 1; }
                
                const r2 = fixSvgWrappedImages(t);
                if (r2.fixed) { t = r2.c; svgFix += r2.count || 1; }
                
                for (const [o, n] of Object.entries(renamed)) {
                    t = t.split(o.split('/').pop()).join(n.split('/').pop());
                }
                
                // Update XHTML references for split images
                for (const [splitKey, parts] of Object.entries(splitImages)) {
                    const origName = splitKey.split('/').pop();
                    const newName = origName.replace(/\.(png|gif|webp|bmp|jpeg)$/i, '.jpg');
                    const blockRegex = new RegExp(
                        `(<(?:p|div)[^>]*>\\s*<span>\\s*<img[^>]*src=["'][^"']*(?:${origName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}|${newName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})[^>]*/>\\s*</span>\\s*</(?:p|div)>)`,
                        'gi'
                    );
                    t = t.replace(blockRegex, (match) => {
                        let result = '';
                        for (let i = 0; i < parts.length; i++) {
                            if (i > 0) result += '\n';
                            let newBlock = match.replace(origName, parts[i].imgName).replace(newName, parts[i].imgName);
                            // Update id attribute to make it unique for each part
                            newBlock = newBlock.replace(/\bid="([^"]+)"/, (m, id) => `id="${id}${parts[i].suffix || '_part' + (i+1)}"`);
                            result += newBlock;
                        }
                        return result;
                    });
                    
                    const simpleImgRegex = new RegExp(
                        `(<img[^>]*src=["'])([^"']*(?:${origName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}|${newName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}))([^>]*/>)`,
                        'gi'
                    );
                    t = t.replace(simpleImgRegex, (match, before, src, after) => {
                        let result = '';
                        for (let i = 0; i < parts.length; i++) {
                            if (i > 0) result += '\n';
                            const partSrc = src.replace(origName, parts[i].imgName).replace(newName, parts[i].imgName);
                            // Update id attribute in before or after to make it unique
                            let partBefore = before.replace(/\bid="([^"]+)"/, (m, id) => `id="${id}${parts[i].suffix || '_part' + (i+1)}"`);
                            let partAfter = after.replace(/\bid="([^"]+)"/, (m, id) => `id="${id}${parts[i].suffix || '_part' + (i+1)}"`);
                            result += `${partBefore}${partSrc}${partAfter}`;
                        }
                        return result;
                    });
                }
                out.file(path, t, { compression: 'DEFLATE', createFolders: false });
            }
            
            // Third pass: update OPF
            if (opfContent) {
                let t = opfContent;
                for (const [o, n] of Object.entries(renamed)) {
                    t = t.split(o.split('/').pop()).join(n.split('/').pop());
                }
                // Replace image media-types for converted files (handles any attribute order)
                t = t.replace(/(<item\b[^>]*href="[^"]+\.jpg"[^>]*)media-type="image\/(png|gif|webp|bmp)"/g, '$1media-type="image/jpeg"');
                t = t.replace(/(<item\b[^>]*)media-type="image\/(png|gif|webp|bmp)"([^>]*href="[^"]+\.jpg")/g, '$1media-type="image/jpeg"$3');
                if (svgFix) t = t.replace(/\s+svg(?=["'\s>])/g, '');
                
                // Calculate OPF directory for relative paths
                const opfDir = opfPath.includes('/') ? opfPath.substring(0, opfPath.lastIndexOf('/')) : '';
                
                // Update OPF manifest for split images
                for (const [splitKey, parts] of Object.entries(splitImages)) {
                    const origName = splitKey.split('/').pop();
                    const origBaseName = origName.replace(/\.[^.]+$/, '');
                    const origImgRegex = new RegExp(`(href=["'][^"']*/?)(${origBaseName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})\\.(?:jpg|jpeg|png|gif|webp|bmp)(["'])`, 'gi');
                    t = t.replace(origImgRegex, `$1${origBaseName}_part1.jpg$3`);
                    
                    // Add manifest entries for additional parts with correct relative paths
                    let manifestAdditions = '';
                    for (let j = 1; j < parts.length; j++) {
                        const p = parts[j];
                        // Calculate href relative to OPF directory
                        let href;
                        if (opfDir && p.path.startsWith(opfDir + '/')) {
                            href = p.path.substring(opfDir.length + 1);
                        } else if (opfDir) {
                            // Different directory - use relative path
                            href = p.path;
                        } else {
                            href = p.path;
                        }
                        manifestAdditions += `<item id="img-${p.id}" href="${href}" media-type="image/jpeg"/>\n`;
                    }
                    // Only replace first occurrence of </manifest>
                    if (manifestAdditions && t.includes('</manifest>')) {
                        t = t.replace('</manifest>', manifestAdditions + '</manifest>');
                    }
                }
                
                const cm = ensureCoverMeta(t);
                if (cm.fixed) t = cm.o;
                out.file(opfPath, t, { compression: 'DEFLATE', createFolders: false });
            }
            
            // Extract main identifier from OPF for NCX sync
            let mainIdentifier = null;
            if (opfContent) {
                // Find unique-identifier attribute in <package>
                const uniqueIdMatch = opfContent.match(/<package[^>]*unique-identifier=["']([^"']+)["']/i);
                if (uniqueIdMatch) {
                    const uniqueIdName = uniqueIdMatch[1];
                    // Find the dc:identifier with that id
                    const idRegex = new RegExp(`<dc:identifier[^>]*id=["']${uniqueIdName}["'][^>]*>([^<]+)</dc:identifier>`, 'i');
                    const idMatch = opfContent.match(idRegex);
                    if (idMatch) {
                        mainIdentifier = idMatch[1].trim();
                    }
                }
                // Fallback: use first dc:identifier
                if (!mainIdentifier) {
                    const firstIdMatch = opfContent.match(/<dc:identifier[^>]*>([^<]+)</i);
                    if (firstIdMatch) {
                        mainIdentifier = firstIdMatch[1].trim();
                    }
                }
            }
            
            // Copy remaining files (skip mimetype - already written first)
            for (const [path, fileObj] of entries) {
                if (fileObj.dir || path === 'mimetype') continue;
                const low = path.toLowerCase();
                if (low.match(/\.(png|gif|webp|bmp|jpg|jpeg)$/) || low.match(/\.(xhtml|html|htm)$/) || low.endsWith('.opf')) continue;
                
                let data = await fileObj.async('arraybuffer');
                if (low.endsWith('.css')) {
                    let t = new TextDecoder().decode(data);
                    for (const [o, n] of Object.entries(renamed)) {
                        t = t.split(o.split('/').pop()).join(n.split('/').pop());
                    }
                    data = new TextEncoder().encode(t);
                } else if (low.endsWith('.ncx')) {
                    let t = new TextDecoder().decode(data);
                    for (const [o, n] of Object.entries(renamed)) {
                        t = t.split(o.split('/').pop()).join(n.split('/').pop());
                    }
                    // Sync NCX identifier with OPF
                    if (mainIdentifier) {
                        t = t.replace(/<meta\s+name=["']dtb:uid["']\s+content=["'][^"']*["']\s*\/?>/gi, 
                            `<meta name="dtb:uid" content="${mainIdentifier}"/>`);
                    }
                    data = new TextEncoder().encode(t);
                }
                out.file(path, data, { compression: 'DEFLATE', createFolders: false });
            }
            
            return await out.generateAsync({ type: 'blob', mimeType: 'application/epub+zip' });
        }

        convertBtn.onclick = async () => {
            if (isBatchMode) {
                // Batch processing
                convertBtn.disabled = true;
                progressSection.classList.add('visible');
                if (advancedMode) {
                    logSection.classList.add('visible');
                    clearLog();
                    log(`Batch conversion: <strong>${batchFiles.length} files</strong>`, '', 'INFO');
                    log(`Quality: ${jpegQuality}% | Rotate & Split: ${selectedForSplit.size} images | Grayscale: ${enableGrayscale ? 'ON' : 'OFF'}`, '', 'INFO');
                }
                
                const results = [];
                let totalOriginalSize = 0;
                let totalNewSize = 0;
                
                for (let i = 0; i < batchFiles.length; i++) {
                    const file = batchFiles[i];
                    batchResults[i] = 'processing';
                    updateBatchList();
                    
                    try {
                        if (advancedMode) log(`<strong>${file.name}</strong> <span class="log-detail">(${formatBytes(file.size)})</span>`, '', 'CONVERT');
                        progress((i / batchFiles.length) * 100, `Converting ${file.name}...`);
                        
                        const blob = await convertSingleFile(file, (p) => {
                            progress((i / batchFiles.length) * 100 + (p / batchFiles.length), `Converting ${file.name}...`);
                        });
                        
                        const savedBytes = file.size - blob.size;
                        const savedPercent = ((savedBytes / file.size) * 100).toFixed(1);
                        
                        totalOriginalSize += file.size;
                        totalNewSize += blob.size;
                        
                        results.push({ name: file.name, blob, success: true, originalSize: file.size });
                        batchResults[i] = 'done';
                        
                        if (advancedMode) {
                            if (savedBytes > 0) {
                                log(`‚úì ${file.name}: <span class="log-detail">${formatBytes(file.size)} ‚Üí ${formatBytes(blob.size)} (<span style="color:#4ade80">-${savedPercent}%</span>)</span>`, 'success', 'DONE');
                            } else {
                                log(`‚úì ${file.name}: <span class="log-detail">${formatBytes(file.size)} ‚Üí ${formatBytes(blob.size)} (+${formatBytes(-savedBytes)})</span>`, 'warning', 'DONE');
                            }
                        }
                    } catch (e) {
                        results.push({ name: file.name, error: e.message, success: false });
                        batchResults[i] = 'error';
                        if (advancedMode) log(`${file.name}: ${e.message}`, 'error', 'ERROR');
                    }
                    updateBatchList();
                }
                
                progress(100, 'Creating ZIP...');
                
                // Create ZIP with all converted files
                const batchZip = new JSZip();
                for (const result of results) {
                    if (result.success) {
                        batchZip.file(result.name.replace('.epub', '_baseline.epub'), result.blob);
                    }
                }
                
                convertedBlob = await batchZip.generateAsync({ type: 'blob' });
                
                const totalSaved = totalOriginalSize - totalNewSize;
                const totalSavedPercent = totalOriginalSize > 0 ? ((totalSaved / totalOriginalSize) * 100).toFixed(1) : 0;
                const batchTimeElapsed = (Date.now() - logStartTime) / 1000;
                
                // Update stat boxes for batch (only in advanced mode)
                if (advancedMode) {
                    fileInfo.classList.add('visible');
                    fileName.textContent = `${batchFiles.length} files`;
                    fileSize.textContent = formatBytes(totalOriginalSize);
                    statTotal.textContent = results.filter(r => r.success).length;
                    statConverted.textContent = results.length;
                    statSize.textContent = formatBytes(totalNewSize);
                    if (totalSaved > 0) {
                        statSaved.textContent = `${formatBytes(totalSaved)} (${totalSavedPercent}%)`;
                    } else {
                        statSaved.textContent = `+${formatBytes(-totalSaved)}`;
                    }
                
                    // Batch summary
                    const successCount = results.filter(r => r.success).length;
                    const failCount = results.length - successCount;
                    const summaryHtml = `
                        <div class="log-summary">
                            <div class="log-summary-title">üìä Batch Summary</div>
                            <table class="log-summary-table">
                                <tr><td>Files processed</td><td class="highlight">${successCount}/${results.length}</td></tr>
                                ${failCount > 0 ? `<tr><td>Failed</td><td style="color:#f87171">${failCount}</td></tr>` : ''}
                                <tr><td>Total original size</td><td>${formatBytes(totalOriginalSize)}</td></tr>
                                <tr><td>Total new size</td><td>${formatBytes(totalNewSize)}</td></tr>
                                <tr><td>Total saved</td><td class="${totalSaved > 0 ? 'saved' : 'increased'}">${totalSaved > 0 ? formatBytes(totalSaved) + ' (' + totalSavedPercent + '%)' : '+' + formatBytes(-totalSaved)}</td></tr>
                                <tr><td>Time</td><td>${batchTimeElapsed.toFixed(1)}s</td></tr>
                            </table>
                        </div>
                    `;
                    logContainer.insertAdjacentHTML('beforeend', summaryHtml);
                    logContainer.scrollTop = logContainer.scrollHeight;
                }
                
                progressSection.classList.remove('visible');
                convertBtn.style.display = 'none';
                qualitySection.style.display = 'none';
                completeSection.classList.add('visible');
                downloadBtn.innerHTML = '<span>‚¨áÔ∏è</span> Download All (ZIP)';
            } else {
                // Single file processing (original code)
                if (!currentFile || !currentZip) return;
                convertBtn.disabled = true; 
                progressSection.classList.add('visible'); 
                if (advancedMode) {
                    logSection.classList.add('visible'); 
                    clearLog();
                }
                progress(0, 'Reading...');
                try {
                    await processSingleFile();
                } catch (e) { 
                    if (advancedMode) logError('Conversion failed: ' + e.message); 
                    else alert('Conversion failed: ' + e.message);
                    console.error(e); 
                    convertBtn.disabled = false; 
                }
            }
        };

        async function processSingleFile() {
            const zip = currentZip;
            if (advancedMode) {
                log(`<strong>${currentFile.name}</strong> <span class="log-detail">(${formatBytes(currentFile.size)})</span>`, '', 'INFO'); 
                log(`Quality: ${jpegQuality}% | Rotate & Split: ${selectedForSplit.size} images | Grayscale: ${enableGrayscale ? 'ON' : 'OFF'}`, '', 'INFO');
            }
            
            const renamed = {};
            zip.forEach(p => { const l = p.toLowerCase(); if (l.match(/\.(png|gif|webp|bmp|jpeg)$/)) renamed[p] = p.replace(/\.(png|gif|webp|bmp|jpeg)$/i, '.jpg'); });
            const imgs = []; zip.forEach(p => { if (p.toLowerCase().match(/\.(png|gif|webp|bmp|jpg|jpeg)$/)) imgs.push(p); });
            if (advancedMode) {
                statTotal.textContent = imgs.length; 
                log(`Found <strong>${imgs.length}</strong> images to process`, '', 'INFO');
            }

            let conv = 0, svgFix = 0, splitCount = 0;
            const out = new JSZip(), entries = Object.entries(zip.files);
            
            // CRITICAL: Write mimetype FIRST per EPUB OCF spec
            if (zip.files['mimetype']) {
                const mimetypeData = await zip.files['mimetype'].async('arraybuffer');
                out.file('mimetype', mimetypeData, { compression: 'STORE', createFolders: false });
            }
            
            // Track split images: originalImageName -> [{path, xhtmlPath, id}, ...]
            const splitImages = {};
            // Track XHTML files that reference images (to update later)
            const xhtmlFiles = {};
            // Track OPF path and content
            let opfPath = null, opfContent = null;
            
            // First pass: process images and collect info
            for (let i = 0; i < entries.length; i++) {
                const [path, file] = entries[i];
                if (file.dir || path === 'mimetype') continue;
                progress(10 + (i / entries.length) * 40, `Processing ${path.split('/').pop()}...`);
                const low = path.toLowerCase();
                
                if (low.match(/\.(png|gif|webp|bmp|jpg|jpeg)$/)) {
                    const data = await file.async('arraybuffer');
                    const result = await processImage(data, path);
                    const { parts, meta } = result;
                    const origFormat = path.split('.').pop().toUpperCase();
                    const fileName = path.split('/').pop();
                    
                    const baseName = path.replace(/\.[^.]+$/, '');
                    const newExt = '.jpg';
                    
                    if (parts.length === 1 && parts[0].suffix === '') {
                        const newPath = renamed[path] || path.replace(/\.[^.]+$/, newExt);
                        out.file(newPath, parts[0].data, { compression: 'DEFLATE', createFolders: false });
                        conv++;
                        
                        // Log detailed image info
                        const newSize = parts[0].data.byteLength;
                        const newW = parts[0].width, newH = parts[0].height;
                        logImage(fileName, meta.origW, meta.origH, origFormat, meta.origSize, newW, newH, newSize, false, 0);
                    } else {
                        // Use full path as key to avoid collisions with same-named files in different folders
                        const splitKey = path;
                        splitImages[splitKey] = [];
                        
                        let totalNewSize = 0;
                        const partsInfo = []; // Collect info about each part for logging
                        for (const part of parts) {
                            const partName = baseName.split('/').pop() + part.suffix + newExt;
                            const partPath = (path.includes('/') ? path.substring(0, path.lastIndexOf('/') + 1) : '') + partName;
                            out.file(partPath, part.data, { compression: 'DEFLATE', createFolders: false });
                            splitImages[splitKey].push({ 
                                path: partPath, 
                                imgName: partName,
                                id: baseName.split('/').pop() + part.suffix,
                                suffix: part.suffix
                            });
                            splitCount++;
                            conv++;
                            totalNewSize += part.data.byteLength;
                            partsInfo.push({ name: partName, width: part.width, height: part.height, size: part.data.byteLength });
                        }
                        
                        // Log split image with details about each part
                        logImage(fileName, meta.origW, meta.origH, origFormat, meta.origSize, 0, 0, totalNewSize, true, parts.length, partsInfo);
                    }
                } else if (low.match(/\.(xhtml|html|htm)$/)) {
                    xhtmlFiles[path] = await file.async('string');
                } else if (low.endsWith('.opf')) {
                    opfPath = path;
                    opfContent = await file.async('string');
                }
            }
            
            // Second pass: update XHTML files - replace each split image with ALL its parts inline
            progress(60, 'Updating XHTML files...');
            
            for (const [path, content] of Object.entries(xhtmlFiles)) {
                let t = content;
                const r = fixSvgCover(t); 
                if (r.fixed) { t = r.c; svgFix += r.count || 1; logFix('SVG cover', path.split('/').pop()); }
                
                const r2 = fixSvgWrappedImages(t);
                if (r2.fixed) { t = r2.c; svgFix += r2.count || 1; logFix(`SVG images (${r2.count})`, path.split('/').pop()); }
                
                // Replace renamed images
                for (const [o, n] of Object.entries(renamed)) {
                    t = t.split(o.split('/').pop()).join(n.split('/').pop());
                }
                
                // For split images: replace single img tag with multiple img tags (all parts)
                for (const [splitKey, parts] of Object.entries(splitImages)) {
                    const origName = splitKey.split('/').pop();
                    const newName = origName.replace(/\.(png|gif|webp|bmp|jpeg)$/i, '.jpg');
                    
                    // Find and replace the whole block: <p|div>...<img>...</p|div>
                    const blockRegex = new RegExp(
                        `(<(?:p|div)[^>]*>\\s*<span>\\s*<img[^>]*src=["'][^"']*(?:${origName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}|${newName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})[^>]*/>\\s*</span>\\s*</(?:p|div)>)`,
                        'gi'
                    );
                    
                    t = t.replace(blockRegex, (match) => {
                        let result = '';
                        for (let i = 0; i < parts.length; i++) {
                            if (i > 0) result += '\n';
                            let newBlock = match
                                .replace(origName, parts[i].imgName)
                                .replace(newName, parts[i].imgName);
                            // Update id attribute to make it unique for each part
                            newBlock = newBlock.replace(/\bid="([^"]+)"/, (m, id) => `id="${id}${parts[i].suffix || '_part' + (i+1)}"`);
                            result += newBlock;
                        }
                        return result;
                    });
                    
                    // Also handle simpler cases: just <img> without wrapper
                    const simpleImgRegex = new RegExp(
                        `(<img[^>]*src=["'])([^"']*(?:${origName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}|${newName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}))([^>]*/>)`,
                        'gi'
                    );
                    
                    t = t.replace(simpleImgRegex, (match, before, src, after) => {
                        let result = '';
                        for (let i = 0; i < parts.length; i++) {
                            if (i > 0) result += '\n';
                            const partSrc = src.replace(origName, parts[i].imgName).replace(newName, parts[i].imgName);
                            // Update id attribute in before or after to make it unique
                            let partBefore = before.replace(/\bid="([^"]+)"/, (m, id) => `id="${id}${parts[i].suffix || '_part' + (i+1)}"`);
                            let partAfter = after.replace(/\bid="([^"]+)"/, (m, id) => `id="${id}${parts[i].suffix || '_part' + (i+1)}"`);
                            result += `${partBefore}${partSrc}${partAfter}`;
                        }
                        return result;
                    });
                }
                
                out.file(path, t, { compression: 'DEFLATE', createFolders: false });
            }
            
            // Third pass: update OPF
            progress(70, 'Updating OPF...');
            if (opfContent) {
                let t = opfContent;
                
                // Replace renamed images
                for (const [o, n] of Object.entries(renamed)) {
                    t = t.split(o.split('/').pop()).join(n.split('/').pop());
                }
                // Replace image media-types for converted files (handles any attribute order)
                t = t.replace(/(<item\b[^>]*href="[^"]+\.jpg"[^>]*)media-type="image\/(png|gif|webp|bmp)"/g, '$1media-type="image/jpeg"');
                t = t.replace(/(<item\b[^>]*)media-type="image\/(png|gif|webp|bmp)"([^>]*href="[^"]+\.jpg")/g, '$1media-type="image/jpeg"$3');
                if (svgFix) t = t.replace(/\s+svg(?=["'\s>])/g, '');
                
                // Calculate OPF directory for relative paths
                const opfDir = opfPath.includes('/') ? opfPath.substring(0, opfPath.lastIndexOf('/')) : '';
                
                // Add split images to manifest and update original image references
                for (const [splitKey, parts] of Object.entries(splitImages)) {
                    const origName = splitKey.split('/').pop();
                    const origBaseName = origName.replace(/\.[^.]+$/, '');
                    
                    // Update original image reference to part1
                    const origImgRegex = new RegExp(`(href=["'][^"']*/?)(${origBaseName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})\\.(?:jpg|jpeg|png|gif|webp|bmp)(["'])`, 'gi');
                    t = t.replace(origImgRegex, `$1${origBaseName}_part1.jpg$3`);
                    
                    // Add manifest entries for parts 2, 3, etc. with correct relative paths
                    let manifestAdditions = '';
                    for (let j = 1; j < parts.length; j++) {
                        const p = parts[j];
                        // Calculate href relative to OPF directory
                        let href;
                        if (opfDir && p.path.startsWith(opfDir + '/')) {
                            href = p.path.substring(opfDir.length + 1);
                        } else if (opfDir) {
                            href = p.path;
                        } else {
                            href = p.path;
                        }
                        manifestAdditions += `<item id="img-${p.id}" href="${href}" media-type="image/jpeg"/>\n`;
                    }
                    // Only replace first occurrence of </manifest>
                    if (manifestAdditions && t.includes('</manifest>')) {
                        t = t.replace('</manifest>', manifestAdditions + '</manifest>');
                    }
                }
                
                const cm = ensureCoverMeta(t); 
                if (cm.fixed) { t = cm.o; logFix('Cover meta', 'Added to OPF manifest'); }
                
                out.file(opfPath, t, { compression: 'DEFLATE', createFolders: false });
            }
            
            // Extract main identifier from OPF for NCX sync
            let mainIdentifier = null;
            if (opfContent) {
                // Find unique-identifier attribute in <package>
                const uniqueIdMatch = opfContent.match(/<package[^>]*unique-identifier=["']([^"']+)["']/i);
                if (uniqueIdMatch) {
                    const uniqueIdName = uniqueIdMatch[1];
                    // Find the dc:identifier with that id
                    const idRegex = new RegExp(`<dc:identifier[^>]*id=["']${uniqueIdName}["'][^>]*>([^<]+)</dc:identifier>`, 'i');
                    const idMatch = opfContent.match(idRegex);
                    if (idMatch) {
                        mainIdentifier = idMatch[1].trim();
                    }
                }
                // Fallback: use first dc:identifier
                if (!mainIdentifier) {
                    const firstIdMatch = opfContent.match(/<dc:identifier[^>]*>([^<]+)</i);
                    if (firstIdMatch) {
                        mainIdentifier = firstIdMatch[1].trim();
                    }
                }
            }

            // Fourth pass: copy remaining files (skip mimetype - already written first)
            progress(80, 'Copying remaining files...');
            for (const [path, file] of entries) {
                if (file.dir || path === 'mimetype') continue;
                const low = path.toLowerCase();
                
                // Skip files we already processed
                if (low.match(/\.(png|gif|webp|bmp|jpg|jpeg)$/) || 
                    low.match(/\.(xhtml|html|htm)$/) || 
                    low.endsWith('.opf')) {
                    continue;
                }
                
                let data = await file.async('arraybuffer');
                
                if (low.endsWith('.css')) {
                    let t = new TextDecoder().decode(data);
                    for (const [o, n] of Object.entries(renamed)) {
                        t = t.split(o.split('/').pop()).join(n.split('/').pop());
                    }
                    data = new TextEncoder().encode(t);
                } else if (low.endsWith('.ncx')) {
                    let t = new TextDecoder().decode(data);
                    for (const [o, n] of Object.entries(renamed)) {
                        t = t.split(o.split('/').pop()).join(n.split('/').pop());
                    }
                    // Sync NCX identifier with OPF
                    if (mainIdentifier) {
                        const oldNcx = t;
                        t = t.replace(/<meta\s+name=["']dtb:uid["']\s+content=["'][^"']*["']\s*\/?>/gi, 
                            `<meta name="dtb:uid" content="${mainIdentifier}"/>`);
                        if (t !== oldNcx) {
                            logFix('NCX identifier', 'Synced with OPF');
                        }
                    }
                    data = new TextEncoder().encode(t);
                }
                
                out.file(path, data, { compression: 'DEFLATE', createFolders: false });
            }

            if (advancedMode) statConverted.textContent = conv; 
            progress(100, 'Generating...');
            convertedBlob = await out.generateAsync({ type: 'blob', mimeType: 'application/epub+zip' });
            
            const originalSize = currentFile.size;
            const newSize = convertedBlob.size;
            const savedBytes = originalSize - newSize;
            const savedPercent = ((savedBytes / originalSize) * 100).toFixed(1);
            const timeElapsed = (Date.now() - logStartTime) / 1000;
            
            if (advancedMode) {
                statSize.textContent = formatBytes(newSize);
                if (savedBytes > 0) {
                    statSaved.textContent = `${formatBytes(savedBytes)} (${savedPercent}%)`;
                } else {
                    statSaved.textContent = `+${formatBytes(-savedBytes)}`;
                }
                
                // Log summary table
                log('Conversion complete!', 'success', 'DONE');
                logSummary(originalSize, newSize, timeElapsed);
                
                // Post-conversion validation
                log('Validating output...', '', 'INFO');
                const finalZip = await JSZip.loadAsync(convertedBlob);
                const postResult = await validateEpub(finalZip, true);
                showValidation(postResult, true);
            }
            
            progressSection.classList.remove('visible'); convertBtn.style.display = 'none'; qualitySection.style.display = 'none'; completeSection.classList.add('visible');
        }

        downloadBtn.onclick = () => { 
            if (!convertedBlob) return; 
            const a = document.createElement('a'); 
            a.href = URL.createObjectURL(convertedBlob); 
            if (isBatchMode) {
                a.download = 'converted_epubs.zip';
            } else {
                a.download = currentFile.name.replace('.epub', '_baseline.epub'); 
            }
            a.click(); 
        };
        
        resetBtn.onclick = () => { 
            currentFile = convertedBlob = currentZip = null; 
            batchFiles = []; batchResults = []; isBatchMode = false;
            fileInput.value = ''; 
            fileInfo.classList.remove('visible'); 
            batchInfo.classList.remove('visible');
            qualitySection.classList.remove('visible'); 
            qualitySection.style.display = ''; 
            progressSection.classList.remove('visible'); 
            logSection.classList.remove('visible'); 
            completeSection.classList.remove('visible'); 
            validationSection.classList.remove('visible');
            imagePicker.classList.remove('visible');
            // Clean up image picker state
            for (const meta of Object.values(imageMetadata)) {
                if (meta.blobUrl) URL.revokeObjectURL(meta.blobUrl);
            }
            selectedForSplit.clear();
            imageMetadata = {};
            imageGrid.innerHTML = '';
            convertBtn.style.display = ''; 
            convertBtn.disabled = true; 
            downloadBtn.innerHTML = '<span>‚¨áÔ∏è</span> Download EPUB';
            clearLog(); 
        };
    </script>
</body>
</html>
